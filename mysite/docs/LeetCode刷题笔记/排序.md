# *排序

*2023/4/12*

---

> 一直想整理一下常见的排序算法
>
> 那么,开始吧!

![img](https://raw.githubusercontent.com/Tianjiangyigeyi/img/master/202304121425470.png)

- n：数据规模
- k："桶"的个数
- In-place：占用常数内存，不占用额外内存
- Out-place：占用额外内存
- 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同



## 冒泡排序(bubble sort)

![img](https://raw.githubusercontent.com/Tianjiangyigeyi/img/master/202304120054972.gif)

- 先排好的是后面的元素

- 时空复杂度:

  - 平均时间复杂度$O(N^2)$
  - 最好情况(优化后的bubble才有最好情况的区别)$: O(N)$,已经升序

  - 最坏情况:$O(N^2)$,降序
  - 空间复杂度:$O(1)$
  - In-place
  - 稳定

```cpp
template <typename T>
inline void Arr<T>::BubbleSort() {
    int size = a.size();
    bool flg;
    for(int i = 0; i < size; ++i){
        flg = false;
        for(int j = 0; j < size - i - 1; ++j){
            if(a[j] > a[j+1]){
                T tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                flg = true;
            }
        }
        if(!flg) break;
    }
}
```



## 选择排序(select sort)

![img](https://raw.githubusercontent.com/Tianjiangyigeyi/img/master/202304121422526.gif)

- 最简单直观的算法,效率极低
- 时空复杂度:
  - 时间复杂度(任何情况):$O(N^2)$
  - 空间复杂度:$O(1)$
  - In-place
  - 不稳定

```cpp
template <typename T>
inline void Arr<T>::SelectSort() {
    int size = a.size();
    for(int i = 0; i < size - 1; ++i){
        int idx = i;
        for(int j = i + 1; j < size; ++j){
            if(a[j] < a[idx]){
                idx = j;
            }
        }
        swap(a[i], a[idx]);
    }
}
```

- 若想让其稳定,选择之后进行的操作为插入到前面而不是交换,这里适合用链表实现

  ```cpp
  #include <iostream>
  using namespace std;
  struct List{
      int val;
      List* next;
      List(int v = 0) : val(v), next(nullptr) { }
  };
  //3 44 38 5 47 15 36 26 27 2 46 4 19 50 48
  
  void SelectSort(List* head)
  {
      List* sorted = head;
      List* sorted_before = head;
      while(sorted->next != nullptr){
          List* sorting = sorted->next;
          List* sorting_before = sorted;
          List* min_before = new List(0x3f3f3f3f);
          min_before->next = sorted;
          while(sorting != nullptr){
              if(sorting->val < min_before->next->val){
                  if(min_before->val == 0x3f3f3f3f) delete min_before;
                  min_before = sorting_before;
              }
              sorting_before = sorting;
              sorting = sorting->next;
          }
          List* tmp = min_before->next;
          if(tmp == sorted){
              sorted_before = sorted;
              sorted = sorted->next;
              continue;
          }
          min_before->next = tmp->next;
          tmp->next = sorted;
          if(sorted_before == sorted){
              tmp->next = head;
              head = tmp;
          }else{
              sorted_before->next = tmp;
              sorted_before = sorted_before->next;
              tmp->next = sorted;
          }
      }
  }
  
  void Print(List* head)
  {
      List* p = head;
      while(p != nullptr){
          cout << p->val << " ";
          p = p->next;
      }
  }
  
  int main()
  {
      List* head = nullptr;
      List* pl = head;
      for(int i = 0; i < 6; ++i){
          int tmp = 0;
          cin >> tmp; 
          if(head == nullptr){
              head = new List(tmp);
              pl = head;
              continue;
          }
          pl->next = new List(tmp);
          pl = pl->next;
      }
      SelectSort(head);
      Print(head);
      return 0;
  }
  ```

  

## 插入排序(insert sort)

![img](https://raw.githubusercontent.com/Tianjiangyigeyi/img/master/202304121534728.gif)