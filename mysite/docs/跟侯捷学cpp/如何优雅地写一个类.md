# 如何优雅地写一个类?

---

> 侯捷面向对象编程上篇第六章内容

```cpp
//该头文件并不完整,有些函数尚未给出,直接编译会出错,只把需要理解的地方标出,供参考

#ifndef _COMPLEX_//防卫式声明
#define _COMPLEX_

class complex
{
public:
    complex (double r = 0, double i = 0)//默认参数
        :re(r), im(i)//initializing list 初始化列表
    { }
    complex& operator += (const complex&);//成员函数,操作符重载
    double real() const { return re; }
    double imag() const { return im; }
    //只要不太长,编译器就会认为是inline函数,速度更快
    //tips:如果在class外部使用inline关键字,编译器将会尽量让他成为内联函数
    //只有成员函数可以使用类型限定符'const',只要该成员函数内不会改变re,im则建议加上'const'
private:
    double re, im;//私有成员不能被外部访问,体现了面向对象编程"封装"的思想
    
    friend complex& _doapl (complex*, const complex&);
    //友元函数,可以访问private成员
};

inline complex&
_doapl(complex* ths, const complex& r)//将会使用ths来保存结果,ths的值会改变,故不用const
{
	ths->re += r.re;
    ths->im += r.im;
    return *ths;
    //question:为什么返回值是*ths,而函数声明的返回值是 complex&
    //answer:*ths是一个complex类型,*ths并不是一个local变量,可以引用
}

inline complex&//考虑到返回值并不是local变量,可以使用引用传值
    //pass by reference 比 pass by value更快,能使用引用传值尽量使用
complex::operator += (const complex& r)//this指针是所有成员函数的隐含参数,指向调用该函数的对象
{
    return _doapl(this, r);
}

inline complex
operator + (const complex& x, const complex& y){
	return complex ( x.real () + y.real() ,
                     x.imag () + y.imag() );//临时声明一个complex对象,在这一行执行完毕后将会灰飞烟灭
}

//重载
inline complex
operator + (const complex& x, double y){
	return complex ( x.real () + y, x.imag () );
}

//传统的cout定义时不会考虑到程序员自己定义的各种类
//为了使用 cout << c1这种用法(c1是一个complex对象),我们考虑到操作符重载一定是作用于操作符右边
//假如在成员函数内操作符重载 '<<' 那将会写成 c1 << cout, 这并不符合程序员的习惯
//于是我们只能将该操作符重载定义为全局函数
#include <iostream>
ostream&//为了可以连续:cout << c1 << c2
operator << (ostream& os, const complex& x)
{
	os << '(' << real(x) << ',' << imag(x) << ')';
}

#endif // _COMPLEX_
```

